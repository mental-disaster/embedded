int Line[20][40] = {
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
};
int Rec[20][40] = {
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0},
{0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0},
{0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0},
{0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0},
{0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0},
{0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0},
{0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0},
{0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0},
{0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0},
{0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0},
{0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0},
{0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0},
{0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0},
{0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0},
{0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0},
{0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
};
int Oval[20][40] = {
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0},
{0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0},
{0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0},
{0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0},
{0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0},
{0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0},
{0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0},
{0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0},
{0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0},
{0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0},
{0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0},
{0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0},
{0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0},
{0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
};
int Free[20][40] = {
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,0,1,1,1,1,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
};
int Sel[20][40] = {
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,1,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0},
{0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0},
{0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0},
{0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0},
{0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0},
{0,0,0,0,0,0,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,1,1,1,1,1,1,0,0,1,1,0,1,1,1,1,0,0},
{0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,0,0,1,0,1,1,0,0,0,0,1,0,0,0},
{0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,0,0,0},
{0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,0,1,1,1,1,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
};
int Era[20][40] = {
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
};
int Cle[20][40] = {
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,1,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,1,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0},
{0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,1,1,1,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,0,0,0,0,0,0,0},
{0,0,1,0,0,0,0,0,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0},
{0,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,1,1,0,0,0,0,0},
{0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0},
{0,0,1,1,1,0,0,1,0,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0},
{0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
};
int Fill[20][40] = {
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0},
{0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0},
{0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0},
{0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0},
{0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0},
{0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0},
{0,0,0,1,1,0,1,1,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0},
{0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0},
{0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0},
{0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0},
{0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0},
{0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0},
{0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
};
int Pen[20][40] = {
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,1,1,1,0,0,0,0,0,0,0,0},
{0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,0,1,1,0,0,0,0,0,0,0},
{0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0},
{0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0},
{0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
};

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/ioctl.h> /* for ioctl */
#include <sys/mman.h> /* for mmap */
#include <sys/types.h>
#include <linux/fb.h> /* for fb_var_screeninfo, FBIOGET_VSCREENINFO */
#include <linux/input.h>
#include <math.h>

#define FBDEVFILE "/dev/fb2"

float a, b, c, d, e, f, k;
unsigned short* pfbdata;
int rpixel;
int pixel;
int offset;
int fd, fbfd;
int flag, clock;
int leftClick, rightUpClick, rightDnClick, midClick;
struct fb_var_screeninfo fbvar;
struct input_event ie;
typedef unsigned char ubyte;

unsigned short makepixel(ubyte r, ubyte g, ubyte b) {
	return (unsigned short)(((r >> 3) << 11) | ((g >> 2) << 5) | (b >> 3));
}

typedef struct _Point {
	int x;
	int y;
}Point;

typedef struct _FD_List {
	int x;
	int y;
	struct _FD_List* link;
}FD_List;

typedef struct _Figure {
	Point start;
	Point end;
	unsigned short color; // Black: 0, White: 1, Red: 2, Green: 3, Blue: 4, Yellow: 5, Cyan: 6, Magenta: 7
	int type; // Line: 0, Rect: 1, Oval: 2, Free: 3, Fill_Rect: 4, Fill_Oval: 5
	FD_List* FD_head;
}Figure;

unsigned short colors[8];

void menu(unsigned short color){
	int i, j; 

	//8 color selector
	for (i = 270; i < 285; i++) {
		for (j = 10; j < 25; j++) {
			offset = j * fbvar.xres + i;
			pixel = makepixel(0, 0, 0);
			*(pfbdata + offset) = pixel;
			if (rightUpClick == 1){
				if (i < 275 && j < 15){
					*(pfbdata + offset) = color;
				}
			}
		}
	}
	for (i = 295; i < 310; i++) {
		for (j = 10; j < 25; j++) {
			offset = j * fbvar.xres + i;
			pixel = makepixel(0, 0, 255);
			*(pfbdata + offset) = pixel;
			if (rightUpClick == 5){
				if (i < 300 && j < 15){
					*(pfbdata + offset) = color;
				}
			}
		}
	}
	for (i = 270; i < 285; i++) {
		for (j = 35; j < 50; j++) {
			offset = j * fbvar.xres + i;
			pixel = makepixel(255, 255, 255);
			*(pfbdata + offset) = pixel;
			if (rightUpClick == 2){
				if (i < 275 && j < 40){
					*(pfbdata + offset) = color;
				}
			}
		}
	}
	for (i = 295; i < 310; i++) {
		for (j = 35; j < 50; j++) {
			offset = j * fbvar.xres + i;
			pixel = makepixel(255, 255, 0);
			*(pfbdata + offset) = pixel;
			if (rightUpClick == 6){
				if (i < 300 && j < 40){
					*(pfbdata + offset) = color;
				}
			}
		}
	}
	for (i = 270; i < 285; i++) {
		for (j = 60; j < 75; j++) {
			offset = j * fbvar.xres + i;
			pixel = makepixel(255, 0, 0);
			*(pfbdata + offset) = pixel;
			if (rightUpClick == 3){
				if (i < 275 && j < 65){
					*(pfbdata + offset) = color;
				}
			}
		}
	}
	for (i = 295; i < 310; i++) {
		for (j = 60; j < 75; j++) {
			offset = j * fbvar.xres + i;
			pixel = makepixel(0, 255, 255);
			*(pfbdata + offset) = pixel;
			if (rightUpClick == 7){
				if (i < 300 && j < 65){
					*(pfbdata + offset) = color;
				}
			}
		}
	}
	for (i = 270; i < 285; i++) {
		for (j = 85; j < 100; j++) {
			offset = j * fbvar.xres + i;
			pixel = makepixel(0, 255, 0);
			*(pfbdata + offset) = pixel;
			if (rightUpClick == 4){
				if (i < 275 && j < 90){
					*(pfbdata + offset) = color;
				}
			}
		}
	}
	for (i = 295; i < 310; i++) {
		for (j = 85; j < 100; j++) {
			offset = j * fbvar.xres + i;
			pixel = makepixel(255, 0, 255);
			*(pfbdata + offset) = pixel;
			if (rightUpClick == 8){
				if (i < 300 && j < 90){
					*(pfbdata + offset) = color;
				}
			}
		}
	}
	//manu_left
	for (i = 10; i < 50; i++) {
		for (j = 10; j < 30; j++) {
			if (Line[j - 10][i - 10]) {
				offset = j * fbvar.xres + i;
				pixel = makepixel(0, 0, 0);
				*(pfbdata + offset) = pixel;
			}
			else {
				offset = j * fbvar.xres + i;
				pixel = makepixel(255, 255, 255);
				*(pfbdata + offset) = pixel;
				if (leftClick == 1){
					*(pfbdata + offset) = color;
				}
			}
		}
	}
	for (i = 10; i < 50; i++) {
		for (j = 40; j < 60; j++) {
			if (Rec[j - 40][i - 10]) {
				offset = j * fbvar.xres + i;
				pixel = makepixel(0, 0, 0);
				*(pfbdata + offset) = pixel;
			}
			else {
				offset = j * fbvar.xres + i;
				pixel = makepixel(255, 255, 255);
				*(pfbdata + offset) = pixel;
				if (leftClick == 2){
					*(pfbdata + offset) = color;
				}
			}
		}
	}
	for (i = 10; i < 50; i++) {
		for (j = 70; j < 90; j++) {
			if (Oval[j - 70][i - 10]) {
				offset = j * fbvar.xres + i;
				pixel = makepixel(0, 0, 0);
				*(pfbdata + offset) = pixel;
			}
			else {
				offset = j * fbvar.xres + i;
				pixel = makepixel(255, 255, 255);
				*(pfbdata + offset) = pixel;
				if (leftClick == 3){
					*(pfbdata + offset) = color;
				}
			}
		}
	}
	for (i = 10; i < 50; i++) {
		for (j = 100; j < 120; j++) {
			if (Free[j - 100][i - 10]) {
				offset = j * fbvar.xres + i;
				pixel = makepixel(0, 0, 0);
				*(pfbdata + offset) = pixel;
			}
			else {
				offset = j * fbvar.xres + i;
				pixel = makepixel(255, 255, 255);
				*(pfbdata + offset) = pixel;
				if (leftClick == 4){
					*(pfbdata + offset) = color;
				}
			}
		}
	}
	for (i = 10; i < 50; i++) {
		for (j = 130; j < 150; j++) {
			if (Sel[j - 130][i - 10]) {
				offset = j * fbvar.xres + i;
				pixel = makepixel(0, 0, 0);
				*(pfbdata + offset) = pixel;
			}
			else {
				offset = j * fbvar.xres + i;
				pixel = makepixel(255, 255, 255);
				*(pfbdata + offset) = pixel;
				if (leftClick == 5){
					*(pfbdata + offset) = color;
				}
			}
		}
	}
	for (i = 10; i < 50; i++) {
		for (j = 160; j < 180; j++) {
			if (Era[j - 160][i - 10]) {
				offset = j * fbvar.xres + i;
				pixel = makepixel(0, 0, 0);
				*(pfbdata + offset) = pixel;
			}
			else {
				offset = j * fbvar.xres + i;
				pixel = makepixel(255, 255, 255);
				*(pfbdata + offset) = pixel;
				if (leftClick == 6){
					*(pfbdata + offset) = color;
				}
			}
		}
	}
	for (i = 10; i < 50; i++) {
		for (j = 190; j < 210; j++) {
			if (Cle[j - 190][i - 10]) {
				offset = j * fbvar.xres + i;
				pixel = makepixel(0, 0, 0);
				*(pfbdata + offset) = pixel;
			}
			else {
				offset = j * fbvar.xres + i;
				pixel = makepixel(255, 255, 255);
				*(pfbdata + offset) = pixel;
				if (leftClick == 7){
					*(pfbdata + offset) = color;
				}
			}
		}
	}
	//manu_right
	for (i = 270; i < 310; i++) {
		for (j = 130; j < 150; j++) {
			if (Pen[j - 130][i - 270]) {
				offset = j * fbvar.xres + i;
				pixel = makepixel(0, 0, 0);
				*(pfbdata + offset) = pixel;
			}
			else {
				offset = j * fbvar.xres + i;
				pixel = makepixel(255, 255, 255);
				*(pfbdata + offset) = pixel;
				if (rightDnClick == 1){
					*(pfbdata + offset) = color;
				}
			}
		}
	}
	for (i = 270; i < 310; i++) {
		for (j = 160; j < 180; j++) {
			if (Fill[j - 160][i - 270]) {
				offset = j * fbvar.xres + i;
				pixel = makepixel(0, 0, 0);
				*(pfbdata + offset) = pixel;
			}
			else {
				offset = j * fbvar.xres + i;
				pixel = makepixel(255, 255, 255);
				*(pfbdata + offset) = pixel;
				if (rightDnClick == 2){
					*(pfbdata + offset) = color;
				}
			}
		}
	}
}

void init_scr()
{
	int i;
	int j;

	//background color
	for (i = 0; i < 320; i++) {
		for (j = 0; j < 240; j++) {
			offset = j * fbvar.xres + i;
			pixel = makepixel(10, 200, 10);
			*(pfbdata + offset) = pixel;
		}
	}

	//screen color
	for (i = 60; i < 260; i++) {
		for (j = 20; j < 220; j++) {
			offset = j * fbvar.xres + i;
			pixel = makepixel(255, 255, 255);
			*(pfbdata + offset) = pixel;
		}
	}


	pixel = makepixel(255, 255, 255);
	menu(pixel);

}


void setCalibration() {
	int i, j, tt, pressure;
	int x[3], y[3], xd[3] = { 50, 150, 300 }, yd[3] = { 100, 50, 200 };
	unsigned short red = makepixel(255, 0, 0);
	for (tt = 0; tt < 3; tt++) {
		for (i = -5; i < 5; i++) {
			offset = (yd[tt] + i) * fbvar.xres + xd[tt];
			*(pfbdata + offset) = red;
			offset = yd[tt] * fbvar.xres + xd[tt] + i;
			*(pfbdata + offset) = red;
		}
		while (1) {
			read(fd, &ie, sizeof(struct input_event));
			if (ie.type == 3) {
				if (ie.code == 0) x[tt] = ie.value;
				else if (ie.code == 1) y[tt] = ie.value;
				else if (ie.code == 24) pressure = ie.value;
				if (pressure == 0)break;
			}
		}
		//printf("%d %d\n%d %d\n", xd[tt], yd[tt], x[tt], y[tt]);
		pressure = -1;
	}
	k = ((x[0] - x[2]) * (y[1] - y[2])) - ((x[1] - x[2]) * (y[0] - y[2]));
	a = ((xd[0] - xd[2]) * (y[1] - y[2])) - ((xd[1] - xd[2]) * (y[0] - y[2]));
	b = ((x[0] - x[2]) * (xd[1] - xd[2])) - ((xd[0] - xd[2]) * (x[1] - x[2]));
	c = (y[0] * ((x[2] * xd[1]) - (x[1] * xd[2]))) + (y[1] * ((x[0] * xd[2]) - (x[2] * xd[0]))) + (y[2] * ((x[1] * xd[0]) - (x[0] * xd[1])));
	d = ((yd[0] - yd[2]) * (y[1] - y[2])) - ((yd[1] - yd[2]) * (y[0] - y[2]));
	e = ((x[0] - x[2]) * (yd[1] - yd[2])) - ((yd[0] - yd[2]) * (x[1] - x[2]));
	f = (y[0] * ((x[2] * yd[1]) - (x[1] * yd[2]))) + (y[1] * ((x[0] * yd[2]) - (x[2] * yd[0]))) + (y[2] * ((x[1] * yd[0]) - (x[0] * yd[1])));
	a = a / k; b = b / k; c = c / k;
	d = d / k; e = e / k; f = f / k;
}

Point getLcd(Point get){
	
	Point tmp;

	tmp.x = a*get.x + b*get.y + c;
	tmp.y = d*get.x + e*get.y + f;

	if (tmp.x < 0){
		tmp.x = 0;
	}
	else if (tmp.x > 319){
		tmp.x = 319;
	}
	if (tmp.y < 0){
		tmp.y = 0;
	}
	else if (tmp.y > 239){
		tmp.y = 239;
	}

	return tmp;
}

void clearLcd() {
	int i, j;
	for (i = 0; i < 240; i++) {
		for (j = 0; j < 320; j++) {
			offset = i * 320 + j;
			*(pfbdata + offset) = 0;
		}
	}
}

void clear_paper(){

	unsigned short white = makepixel(255, 255, 255);
	int i, j;
	for (i = 60; i < 260; i++) {
		for (j = 20; j < 220; j++){
			offset = j * 320 + i;
			*(pfbdata + offset) = white;
		}
	}
}
void makeLine(Figure f, unsigned short color){

	int x, tmp, start_x, end_x, a, b;
	float g, y;

	if (f.end.x > 259){
		f.end.x = 259;
	}
	if (f.start.x < 61){
		f.start.x = 61;
	}
	// vertical
	if (f.end.x == f.start.x){
		if (f.start.y > f.end.y){
			tmp = f.start.y;
			f.start.y = f.end.y;
			f.end.y = tmp;
		}
		for (x = f.start.y; x < f.end.y; x++){
			for (a = 0; a < 3; a++){
				for (b = 0; b < 3; b++){
					if (x > 25 && x < 219){
						if (f.end.x > 65 && f.end.x < 259){					
							offset = (x - a) * 320 + (f.end.x - b);
							*(pfbdata + offset) = color;
						}
					}
				}
			}
		}
	}
	else{
		g = (float)(f.end.y - f.start.y) / (f.end.x - f.start.x);


		if (f.start.x > f.end.x) {
			start_x = f.end.x;
			end_x = f.start.x;
		}
		else {
			start_x = f.start.x;
			end_x = f.end.x;
		}
		// in-paper
		if (start_x < 61){
			start_x = 61;
		}
		if (end_x > 259){
			end_x = 259;
		}

		y = g;
		y *= (start_x - f.start.x);
		y += f.start.y;
		tmp = y;
		for (x = start_x; x < end_x; x++){
			y = g;
			y *= (x - f.start.x);
			y += f.start.y;
			while (tmp < y) {
				if (tmp > 219) {
					tmp = 219;
					break;
				}
				for (a = 0; a < 5; a++) {
					for (b = 0; b < 5; b++) {
						if (x > 65 && x < 259){
							if (tmp > 25 && tmp < 219){
								offset = (tmp - a) * 320 + (x - b);
								*(pfbdata + offset) = color;
							}
						}
					}
				}
				tmp++;
			}
			while (tmp > y) {
				if (tmp < 21) {
					tmp = 21;
					break;
				}
				for (a = 0; a < 5; a++) {
					for (b = 0; b < 5; b++) {
						if (x > 65 && x < 259){
							if (tmp > 25 && tmp < 219){
								offset = (tmp - a) * 320 + (x - b);
								*(pfbdata + offset) = color;
							}
						}
					}
				}
				tmp--;
			}

			tmp = y;

			if (tmp < 21) {
				tmp = 21;
			}
			else if (tmp > 219) {
				tmp = 219;
			}

			for (a = 0; a < 5; a++){
				for (b = 0; b < 5; b++){
					if (x > 65 && x < 259){
						if (tmp > 25 && tmp < 219){
							offset = (tmp - a) * 320 + (x - b);
							*(pfbdata + offset) = color;
						}
					}
				}
			}
		}
	}	
}

void makeRect(Figure f, unsigned short color) {
	int i, j, tmp, a, b;

	if (f.start.x > f.end.x) {
		tmp = f.start.x;
		f.start.x = f.end.x;
		f.end.x = tmp;
	}
	if (f.start.y > f.end.y) {
		tmp = f.start.y;
		f.start.y = f.end.y;
		f.end.y = tmp;
	}

	for (j = f.start.x; j < f.end.x; j++){
		for (a = 0; a < 5; a++){
			for (b = 0; b < 5; b++){
				if (j > 66 && j < 259){
					if (f.start.y > 26 && f.start.y < 219){
						offset = (f.start.y - a) * 320 + (j - b);
						*(pfbdata + offset) = color;
					}
					if (f.end.y > 26 && f.end.y < 219){
						offset = (f.end.y - a) * 320 + (j - b);
						*(pfbdata + offset) = color;
					}
				}
			}
		}
	}
	for (i = f.start.y; i < f.end.y; i++){
		for (a = 0; a < 5; a++){
			for (b = 0; b < 5; b++){
				if (i > 26 && i < 219){
					if (f.start.x > 66 && f.start.x < 259){
						offset = (i - a) * 320 + (f.start.x - b);
						*(pfbdata + offset) = color;
					}
					if (f.end.x > 66 && f.end.x < 259){
						offset = (i - a) * 320 + (f.end.x - b);
						*(pfbdata + offset) = color;
					}
				}
			}
		}
	}
}
void makeOval(Figure f, unsigned short color){
	int x, y, tmp;
	float a, b, center_x, center_y;
	
	center_x = f.start.x + (float)(f.end.x - f.start.x) / 2;
	center_y = f.start.y + (float)(f.end.y - f.start.y) / 2;
	b = abs(f.end.x - f.start.x) / 2;
	a = abs(f.end.y - f.start.y) / 2;

	if (f.start.x > f.end.x){
		tmp = f.start.x;
		f.start.x = f.end.x;
		f.end.x = tmp;
	}
	if (f.start.y > f.end.y){
		tmp = f.start.y;
		f.start.y = f.end.y;
		f.end.y = tmp;
	}
	for (x = f.start.x; x < f.end.x; x++){
		for (y = f.start.y; y < f.end.y; y++){
			// matching Oval
			if (pow((a-5), 2) * pow((b-5), 2) <= pow((a-5), 2) * pow((x-center_x), 2) + pow((b-5), 2) * pow((y-center_y), 2)){
				if (pow(a, 2) * pow(b, 2) >= pow(a, 2) * pow((x-center_x), 2) + pow(b, 2) * pow((y-center_y), 2)){
					// in-paper
					if (y > 25 && y < 219){
						if (x > 65 && x < 259){
							offset = y * 320 + x;
							*(pfbdata + offset) = color;
						}
					}
				}
			}
		}
	}
				 
}

FD_List* Free_draw(Figure fig, unsigned short color) {
	int pressure;
	FD_List* next = (FD_List*)malloc(sizeof(FD_List));;
	FD_List* head = next;
	Figure hi;
	Point Loc;
	int i;
	int j;

	hi.start.x = fig.end.x;
	hi.start.y = fig.end.y;

	while (1) {
		read(fd, &ie, sizeof(struct input_event));
		if (ie.type == 3) {
			if (ie.code == 0) {
				Loc.x = ie.value;
			}
			else if (ie.code == 1) {
				Loc.y = ie.value;
			}
			else if (ie.code == 24) {
				pressure = ie.value;
				if (pressure > 0) {
					hi.end = getLcd(Loc);

					next->x = hi.end.x - fig.end.x;
					next->y = hi.end.y - fig.end.y;

					makeLine(hi, color);

					hi.start.x = hi.end.x;
					hi.start.y = hi.end.y;

					next->link = (FD_List*)malloc(sizeof(FD_List));
					next = next->link;
					next->link = NULL;
				}

				else break;
			}
		}
	}

	return head;
}

void makeRect_Fill(Figure f, unsigned short color) {
	int i, j, tmp, a, b;

	if (f.start.x > f.end.x) {
		tmp = f.start.x;
		f.start.x = f.end.x;
		f.end.x = tmp;
	}
	if (f.start.y > f.end.y) {
		tmp = f.start.y;
		f.start.y = f.end.y;
		f.end.y = tmp;
	}

	// in-paper
	if (f.start.x < 61) {
		f.start.x = 61;
	}
	else if (f.end.x > 259) {
		f.end.x = 259;
	}
	if (f.start.y < 21) {
		f.start.y = 21;
	}
	else if (f.end.y > 219) {
		f.end.y = 219;
	}

	for (i = f.start.x; i < f.end.x; i++)
		for (j = f.start.y; j < f.end.y; j++)
			for (a = 0; a < 3; a++)
				for (b = 0; b < 3; b++) {
					offset = (j - a) * 320 + (i - b);
					*(pfbdata + offset) = color;
				}
}

void makeOval_Fill(Figure f, unsigned short color) {
	int x, y, tmp;
	float a, b, center_x, center_y;

	center_x = f.start.x + (float)(f.end.x - f.start.x) / 2;
	center_y = f.start.y + (float)(f.end.y - f.start.y) / 2;
	b = abs(f.end.x - f.start.x) / 2;
	a = abs(f.end.y - f.start.y) / 2;

	if (f.start.x > f.end.x) {
		tmp = f.start.x;
		f.start.x = f.end.x;
		f.end.x = tmp;
	}
	if (f.start.y > f.end.y) {
		tmp = f.start.y;
		f.start.y = f.end.y;
		f.end.y = tmp;
	}
	// in-paper
	if (f.start.x < 61) {
		f.start.x = 61;
	}
	else if (f.end.x > 260) {
		f.end.x = 260;
	}
	if (f.start.y < 21) {
		f.start.y = 21;
	}
	else if (f.end.y > 220) {
		f.end.y = 220;
	}

	for (x = f.start.x; x < f.end.x; x++) {
		for (y = f.start.y; y < f.end.y; y++) {
			if (!(pow((a- 2), 2) * pow((b - 2), 2) <= pow((a - 2), 2) * pow((x - center_x), 2) + pow((b - 2), 2) * pow((y - center_y), 2))) {
					offset = y * 320 + x;
					*(pfbdata + offset) = color;
			}
		}
	}
}


int Erase(Figure fig, Figure* figs, int figIdx) {
	int i, j, tmp, a, b, start_x, end_x, x;
	int c_x, c_y, o_a, o_b;
	float g, y;
	FD_List* next;
	Figure hi;

	if (fig.start.x < 61 || fig.start.x > 259){
		return figIdx;
	}
	if (fig.start.y < 21 || fig.start.y > 219){
		return figIdx;
	}

	for (i = figIdx - 1; i >= 0; i--) {
		//printf("Erase: %d\n", i);
		switch (figs[i].type) {
		// Line
		case 0:	
			hi.start.x = figs[i].start.x; hi.start.y = figs[i].start.y;
			hi.end.x = figs[i].end.x; hi.end.y = figs[i].end.y;

			// vertical
			if (hi.end.x == hi.start.x){
				if (hi.start.y > hi.end.y){
					tmp = hi.start.y;
					hi.start.y = hi.end.y;
					hi.end.y = tmp;
				}
				for (x = hi.start.y; x < hi.end.y; x++){
					if (fig.start.y >= x - 3 && fig.start.y <= x){
						if (fig.start.x >= hi.end.x - 3 && fig.start.x <= hi.end.x){
							for (j = i; j <= figIdx - 1; j++){
								figs[j] = figs[j + 1];
							}
							figIdx--;
							goto END;
						}
					}
				}
			}
			else{
				g = (float)(hi.end.y - hi.start.y) / (hi.end.x - hi.start.x);

				if (hi.start.x > hi.end.x) {
					start_x = hi.end.x;
					end_x = hi.start.x;
				}
				else {
					start_x = hi.start.x;
					end_x = hi.end.x;
				}

				y = g;
				y *= (fig.start.x - hi.start.x);
				y += hi.start.y;
				tmp = y;
				for (x = start_x; x < end_x; x++){
						y = g;
						y *= (x - hi.start.x);
						y += hi.start.y;
						while (tmp < y) {
							if (tmp > 219) {
								tmp = 219;
								break;
							}
							if (fig.start.x >= x - 5 && fig.start.x <= x){
								if (fig.start.y >= tmp - 5 && fig.start.y <= tmp){
									for (j = i; j <= figIdx - 1; j++){
										figs[j] = figs[j + 1];
									}
									figIdx--;
									goto END;
								}	
							}
							tmp++;
						}
						while (tmp > y) {
							if (tmp < 21) {
								tmp = 21;
								break;
							}
							if (fig.start.x >= x - 5 && fig.start.x <= x){
								if (fig.start.y >= tmp - 5 && fig.start.y <= tmp){
									for (j = i; j <= figIdx - 1; j++){
										figs[j] = figs[j + 1];
									}
									figIdx--;
									goto END;
								}	
							}
							tmp--;
						}
		
						tmp = y;

						if (tmp < 21) {
							tmp = 21;
						}
						else if (tmp > 219) {
							tmp = 219;
						}
						if (fig.start.x >= x - 5 && fig.start.x <= x){
							if (fig.start.y >= tmp - 5 && fig.start.y <= tmp){
								for (j = i; j <= figIdx - 1; j++){
									figs[j] = figs[j + 1];
								}
								figIdx--;
								goto END;
							}	
						}

				}
			}




		// Rect
		case 1:
			hi.start.x = figs[i].start.x; hi.start.y = figs[i].start.y;
			hi.end.x = figs[i].end.x; hi.end.y = figs[i].end.y;
			if (hi.start.x > hi.end.x){
				tmp = hi.start.x;
				hi.start.x = hi.end.x;
				hi.end.x = tmp;
			}
			if (hi.start.y > hi.end.y){
				tmp = hi.start.y;
				hi.start.y = hi.end.y;
				hi.end.y = tmp;
			}
			//printf("Erase_Rect - s_x, s_y, e_x, e_y: %d %d %d %d\n", hi.start.x, hi.start.y, hi.end.x, hi.end.y);
			if ((fig.start.y >= hi.start.y && fig.start.y <= hi.start.y + 3) || (fig.start.y <= hi.end.y && fig.start.y >= hi.end.y - 3) || (fig.start.x >= hi.start.x && fig.start.x <= hi.start.x + 3) || (fig.start.x <= hi.end.x && fig.start.x >= hi.end.x - 3)){
							for (j = i; j <= figIdx - 1; j++){
								figs[j] = figs[j + 1];
							}
							figIdx--;
							goto END;
			}
			
			break;
		// Oval
		case 2:
			hi.start.x = figs[i].start.x; hi.start.y = figs[i].start.y;
			hi.end.x = figs[i].end.x; hi.end.y = figs[i].end.y;
			if (hi.start.x > hi.end.x){
				tmp = hi.start.x;
				hi.start.x = hi.end.x;
				hi.end.x = tmp;
			}
			if (hi.start.y > hi.end.y){
				tmp = hi.start.y;
				hi.start.y = hi.end.y;
				hi.end.y = tmp;
			}

			c_x = (float)(hi.end.x + hi.start.x) / 2;
			c_y = (float)(hi.end.y + hi.start.y) / 2;
			o_a = (float)(hi.end.x - hi.start.x) / 2;
			o_b = (float)(hi.end.y = hi.start.y) / 2;

			if ((pow(o_a, 2) * pow((fig.start.x - c_x), 2) + pow(o_b, 2) * pow((fig.start.y - c_y), 2)) <= pow(o_a*o_b, 2)){
				if ((pow((o_a-5), 2) * pow((fig.start.x - c_x), 2) + pow((o_b-5), 2) * pow((fig.start.y - c_y), 2)) > pow((o_a-5)*(o_b-3), 2)){
					for (j = i; j <= figIdx - 1; j++){
						figs[j] = figs[j + 1];
					}
					figIdx--;
					goto END;
				}
			}
			
			break;
		// free_draw
		case 3:
			next = figs[i].FD_head;
			hi.start.x = figs[i].start.x; hi.start.y = figs[i].start.y;
			hi.end.x = next->x;	hi.end.y = next->y;
			//hi로 그리는 라인(makeLine)이 선택에 포함되어있는지 확인하는 코드

			// vertical
                        if (hi.end.x == hi.start.x){
                                if (hi.start.y > hi.end.y){
                                        tmp = hi.start.y;
                                        hi.start.y = hi.end.y;
                                        hi.end.y = tmp;
                                }
                                for (x = hi.start.y; x < hi.end.y; x++){
                                        if (fig.start.y >= x - 3 && fig.start.y <= x){
                                                if (fig.start.x >= hi.end.x - 3 && fig.start.x <= hi.end.x){
                                                        for (j = i; j <= figIdx - 1; j++){
                                                                figs[j] = figs[j + 1];
                                                        }
                                                        figIdx--;
                                                        goto END;
                                                }
                                        }
                                }
                        }
                        else{
                                g = (float)(hi.end.y - hi.start.y) / (hi.end.x - hi.start.x);

                                if (hi.start.x > hi.end.x) {
                                        start_x = hi.end.x;
                                        end_x = hi.start.x;
                                }
                                else {
                                        start_x = hi.start.x;
                                        end_x = hi.end.x;
                                }

                                y = g;
                                y *= (fig.start.x - hi.start.x);
                                y += hi.start.y;
                                tmp = y;
                                for (x = start_x; x < end_x; x++){
                                                y = g;
                                                y *= (x - hi.start.x);
                                                y += hi.start.y;
                                                while (tmp < y) {
                                                        if (tmp > 219) {
                                                                tmp = 219;
                                                                break;
                                                        }
                                                        if (fig.start.x >= x - 5 && fig.start.x <= x){
                                                                if (fig.start.y >= tmp - 5 && fig.start.y <= tmp){
                                                                        for (j = i; j <= figIdx - 1; j++){
                                                                                figs[j] = figs[j + 1];
                                                                        }
                                                                        figIdx--;
                                                                        goto END;
                                                                }
 							}
                                                        tmp++;
                                                }
                                                while (tmp > y) {
                                                        if (tmp < 21) {
                                                                tmp = 21;
                                                                break;
                                                        }
                                                        if (fig.start.x >= x - 5 && fig.start.x <= x){
                                                                if (fig.start.y >= tmp - 5 && fig.start.y <= tmp){
                                                                        for (j = i; j <= figIdx - 1; j++){
                                                                                figs[j] = figs[j + 1];
                                                                        }
                                                                        figIdx--;
                                                                        goto END;
                                                                }
                                                        }
                                                        tmp--;
                                                }

                                                tmp = y;

                                                if (tmp < 21) {
                                                        tmp = 21;
                                                }
                                                else if (tmp > 219) {
                                                        tmp = 219;
                                                }
                                                if (fig.start.x >= x - 5 && fig.start.x <= x){
                                                        if (fig.start.y >= tmp - 5 && fig.start.y <= tmp){
                                                                for (j = i; j <= figIdx - 1; j++){
                                                                        figs[j] = figs[j + 1];
                                                                }
                                                                figIdx--;
                                                                goto END;
                                                        }
                                                }

                                }
                        }


			while (next->link != NULL) {
				next = next->link;
				hi.start.x = hi.end.x; hi.start.y = hi.end.y;
				hi.end.x = next->x; hi.end.y = next->y;
				//hi로 그리는 라인(makeLine)이 선택에 포함되어있는지 확인하는 코드
				
				// vertical
                        if (hi.end.x == hi.start.x){
                                if (hi.start.y > hi.end.y){
                                        tmp = hi.start.y;
                                        hi.start.y = hi.end.y;
                                        hi.end.y = tmp;
                                }
                                for (x = hi.start.y; x < hi.end.y; x++){
                                        if (fig.start.y >= x - 3 && fig.start.y <= x){
                                                if (fig.start.x >= hi.end.x - 3 && fig.start.x <= hi.end.x){
                                                        for (j = i; j <= figIdx - 1; j++){
                                                                figs[j] = figs[j + 1];
                                                        }
                                                        figIdx--;
                                                        goto END;
                                                }
                                        }
                                }
                        }
                        else{
                                g = (float)(hi.end.y - hi.start.y) / (hi.end.x - hi.start.x);

                                if (hi.start.x > hi.end.x) {
                                        start_x = hi.end.x;
                                        end_x = hi.start.x;
                                }
                                else {
                                        start_x = hi.start.x;
                                        end_x = hi.end.x;
                                }

                                y = g;
                                y *= (fig.start.x - hi.start.x);
                                y += hi.start.y;
                                tmp = y;
                                for (x = start_x; x < end_x; x++){
                                                y = g;
                                                y *= (x - hi.start.x);
                                                y += hi.start.y;
                                                while (tmp < y) {
                                                        if (tmp > 219) {
                                                                tmp = 219;
                                                                break;
                                                        }
                                                        if (fig.start.x >= x - 5 && fig.start.x <= x){
                                                                if (fig.start.y >= tmp - 5 && fig.start.y <= tmp){
                                                                        for (j = i; j <= figIdx - 1; j++){
                                                                                figs[j] = figs[j + 1];
                                                                        }
                                                                        figIdx--;
                                                                        goto END;
                                                                }
 							}
                                                        tmp++;
                                                }
                                                while (tmp > y) {
                                                        if (tmp < 21) {
                                                                tmp = 21;
                                                                break;
                                                        }
                                                        if (fig.start.x >= x - 5 && fig.start.x <= x){
                                                                if (fig.start.y >= tmp - 5 && fig.start.y <= tmp){
                                                                        for (j = i; j <= figIdx - 1; j++){
                                                                                figs[j] = figs[j + 1];
                                                                        }
                                                                        figIdx--;
                                                                        goto END;
                                                                }
                                                        }
                                                        tmp--;
                                                }

                                                tmp = y;

                                                if (tmp < 21) {
                                                        tmp = 21;
                                                }
                                                else if (tmp > 219) {
                                                        tmp = 219;
                                                }
                                                if (fig.start.x >= x - 5 && fig.start.x <= x){
                                                        if (fig.start.y >= tmp - 5 && fig.start.y <= tmp){
                                                                for (j = i; j <= figIdx - 1; j++){
                                                                        figs[j] = figs[j + 1];
                                                                }
                                                                figIdx--;
                                                                goto END;
                                                        }
                                                }

                                }
                        }


			}
			break;
		// Fill_Rect
		case 4:
			hi.start.x = figs[i].start.x; hi.start.y = figs[i].start.y;
			hi.end.x = figs[i].end.x; hi.end.y = figs[i].end.y;
			if (hi.start.x > hi.end.x){
				tmp = hi.start.x;
				hi.start.x = hi.end.x;
				hi.end.x = tmp;
			}
			if (hi.start.y > hi.end.y){
				tmp = hi.start.y;
				hi.start.y = hi.end.y;
				hi.end.y = tmp;
			}
			
			if (hi.start.x <= fig.start.x && hi.end.x >= fig.start.x){
				if (hi.start.y <= fig.start.y && hi.end.y >= fig.start.y){
					for (j = i; j <= figIdx - 1; j++){
						figs[j] = figs[j + 1];
					}
					figIdx--;
					goto END;
				}
			}
			break;
		// Fill_Oval
		case 5:
			hi.start.x = figs[i].start.x; hi.start.y = figs[i].start.y;
			hi.end.x = figs[i].end.x; hi.end.y = figs[i].end.y;
			if (hi.start.x > hi.end.x){
				tmp = hi.start.x;
				hi.start.x = hi.end.x;
				hi.end.x = tmp;
			}
			if (hi.start.y > hi.end.y){
				tmp = hi.start.y;
				hi.start.y = hi.end.y;
			}

			c_x = (float)(hi.end.x + hi.start.x) / 2;
			c_y = (float)(hi.end.y + hi.start.y) / 2;
			o_a = (float)(hi.end.x - hi.start.x) / 2;
			o_b = (float)(hi.end.y = hi.start.y) / 2;

			if ((pow(o_a, 2) * pow((fig.start.x - c_x), 2) + pow(o_b, 2) * pow((fig.start.y - c_y), 2)) <= pow(o_a*o_b, 2)){
				for (j = i; j <= figIdx - 1; j++){
					figs[j] = figs[j + 1];
				}
				figIdx--;
				goto END;
			}
			break;
		default:
			break;
		}
	}
	END:
		return figIdx;

}

int Select(Figure fig, Figure* figs, int figIdx){
	int i, j, tmp, a, b, idx = -1, start_x, end_x, x;
	int c_x, c_y, o_a, o_b;
	float g, y;
	FD_List* next;
	Figure hi;

	if (fig.start.x < 60 || fig.start.x > 260){
		return idx;
	}
	if (fig.start.y < 20 || fig.start.y > 220){
		return idx;
	}

	for (i = figIdx - 1; i >= 0; i--) {
		//printf("Select %d\n", i);
		switch (figs[i].type) {
		// Line
		case 0: 
			hi.start.x = figs[i].start.x; hi.start.y = figs[i].start.y;
			hi.end.x = figs[i].end.x; hi.end.y = figs[i].end.y;

			// vertical
                        if (hi.end.x == hi.start.x){
                                if (hi.start.y > hi.end.y){
                                        tmp = hi.start.y;
                                        hi.start.y = hi.end.y;
                                        hi.end.y = tmp;
                                }
                                for (x = hi.start.y; x < hi.end.y; x++){
                                        if (fig.start.y >= x - 3 && fig.start.y <= x){
                                                if (fig.start.x >= hi.end.x - 3 && fig.start.x <= hi.end.x){
                                                        idx = i;
                                                        goto END;
                                                }
                                        }
                                }
                        }
                        else{
                                g = (float)(hi.end.y - hi.start.y) / (hi.end.x - hi.start.x);

                                if (hi.start.x > hi.end.x) {
                                        start_x = hi.end.x;
                                        end_x = hi.start.x;
                                }
                                else {
                                        start_x = hi.start.x;
                                        end_x = hi.end.x;
                                }

                                y = g;
                                y *= (fig.start.x - hi.start.x);
                                y += hi.start.y;
                                tmp = y;
                                for (x = start_x; x < end_x; x++){
                                                y = g;
                                                y *= (x - hi.start.x);
                                                y += hi.start.y;
                                                while (tmp < y) {
                                                        if (tmp > 219) {
                                                                tmp = 219;
                                                                break;
                                                        }
                                                        if (fig.start.x >= x - 5 && fig.start.x <= x){
                                                                if (fig.start.y >= tmp - 5 && fig.start.y <= tmp){
                                                                        idx = i;
                                                                        goto END;
                                                                }
						 	}
                                                        tmp++;
                                                }
                                                while (tmp > y) {
                                                        if (tmp < 21) {
                                                                tmp = 21;
                                                                break;
                                                        }
                                                        if (fig.start.x >= x - 5 && fig.start.x <= x){
                                                                if (fig.start.y >= tmp - 5 && fig.start.y <= tmp){
                                                                        idx = i;
                                                                        goto END;
                                                                }
                                                        }
                                                        tmp--;
                                                }

                                                tmp = y;

                                                if (tmp < 21) {
                                                        tmp = 21;
                                                }
                                                else if (tmp > 219) {
                                                        tmp = 219;
                                                }
                                                if (fig.start.x >= x - 5 && fig.start.x <= x){
                                                        if (fig.start.y >= tmp - 5 && fig.start.y <= tmp){
                                                                idx = i;
                                                                goto END;
                                                        }
                                                }

                                }
                        }



			break;
		// Rect
		case 1:
			hi.start.x = figs[i].start.x; hi.start.y = figs[i].start.y;
			hi.end.x = figs[i].end.x; hi.end.y = figs[i].end.y;
			if (hi.start.x > hi.end.x){
				tmp = hi.start.x;
				hi.start.x = hi.end.x;
				hi.end.x = tmp;
			}
			if (hi.start.y > hi.end.y){
				tmp = hi.start.y;
				hi.start.y = hi.end.y;
				hi.end.y = tmp;
			}
			//printf("Erase_Rect - s_x, s_y, e_x, e_y: %d %d %d %d\n", hi.start.x, hi.start.y, hi.end.x, hi.end.y);
			if ((fig.start.y >= hi.start.y && fig.start.y <= hi.start.y + 3) || (fig.start.y <= hi.end.y && fig.start.y >= hi.end.y - 3) || (fig.start.x >= hi.start.x && fig.start.x <= hi.start.x + 3) || (fig.start.x <= hi.end.x && fig.start.x >= hi.end.x - 3)){
				idx = i;
				goto END;
			}
			break;
		// Oval
		case 2:
			hi.start.x = figs[i].start.x; hi.start.y = figs[i].start.y;
			hi.end.x = figs[i].end.x; hi.end.y = figs[i].end.y;
			if (hi.start.x > hi.end.x){
				tmp = hi.start.x;
				hi.start.x = hi.end.x;
				hi.end.x = tmp;
			}
			if (hi.start.y > hi.end.y){
				tmp = hi.start.y;
				hi.start.y = hi.end.y;
				hi.end.y = tmp;
			}

			c_x = (float)(hi.end.x + hi.start.x) / 2;
			c_y = (float)(hi.end.y + hi.start.y) / 2;
			o_a = (float)(hi.end.x - hi.start.x) / 2;
			o_b = (float)(hi.end.y = hi.start.y) / 2;

			if ((pow(o_a, 2) * pow((fig.start.x - c_x), 2) + pow(o_b, 2) * pow((fig.start.y - c_y), 2)) <= pow(o_a*o_b, 2)){
				if ((pow((o_a-12), 2) * pow((fig.start.x - c_x), 2) + pow((o_b-12), 2) * pow((fig.start.y - c_y), 2)) >= pow((o_a-12)*(o_b-12), 2)){
					idx = i;
					goto END;
				}
			}
			break;
		// free_draw
		case 3:
			next = figs[i].FD_head;
			hi.start.x = figs[i].start.x; hi.start.y = figs[i].start.y;
			hi.end.x = next->x;	hi.end.y = next->y;
			//hi로 그리는 라인(makeLine)이 선택에 포함되어있는지 확인하는 코드
			
			// vertical
                        if (hi.end.x == hi.start.x){
                                if (hi.start.y > hi.end.y){
                                        tmp = hi.start.y;
                                        hi.start.y = hi.end.y;
                                        hi.end.y = tmp;
                                }
                                for (x = hi.start.y; x < hi.end.y; x++){
                                        if (fig.start.y >= x - 3 && fig.start.y <= x){
                                                if (fig.start.x >= hi.end.x - 3 && fig.start.x <= hi.end.x){
                                                        idx = i;
                                                        goto END;
                                                }
                                        }
                                }
                        }
                        else{
                                g = (float)(hi.end.y - hi.start.y) / (hi.end.x - hi.start.x);

                                if (hi.start.x > hi.end.x) {
                                        start_x = hi.end.x;
                                        end_x = hi.start.x;
                                }
                                else {
                                        start_x = hi.start.x;
                                        end_x = hi.end.x;
                                }

                                y = g;
                                y *= (fig.start.x - hi.start.x);
                                y += hi.start.y;
                                tmp = y;
                                for (x = start_x; x < end_x; x++){
                                                y = g;
                                                y *= (x - hi.start.x);
                                                y += hi.start.y;
                                                while (tmp < y) {
                                                        if (tmp > 219) {
                                                                tmp = 219;
                                                                break;
                                                        }
                                                        if (fig.start.x >= x - 5 && fig.start.x <= x){
                                                                if (fig.start.y >= tmp - 5 && fig.start.y <= tmp){
                                                                        idx = i;
                                                                        goto END;
                                                                }
							}
                                                        tmp++;
                                                }
                                                while (tmp > y) {
                                                        if (tmp < 21) {
                                                                tmp = 21;
                                                                break;
                                                        }
                                                        if (fig.start.x >= x - 5 && fig.start.x <= x){
                                                                if (fig.start.y >= tmp - 5 && fig.start.y <= tmp){
                                                                        idx = i;
                                                                        goto END;
                                                                }
                                                        }
                                                        tmp--;
                                                }

                                                tmp = y;

                                                if (tmp < 21) {
                                                        tmp = 21;
                                                }
                                                else if (tmp > 219) {
                                                        tmp = 219;
                                                }
                                                if (fig.start.x >= x - 5 && fig.start.x <= x){
                                                        if (fig.start.y >= tmp - 5 && fig.start.y <= tmp){
                                                                idx = i;
                                                                goto END;
                                                        }
                                                }

                                }
                        }


			while (next->link != NULL) {
				next = next->link;
				hi.start.x = hi.end.x; hi.start.y = hi.end.y;
				hi.end.x = next->x; hi.end.y = next->y;
				//hi로 그리는 라인(makeLine)이 선택에 포함되어있는지 확인하는 코드
				
				// vertical
	                        if (hi.end.x == hi.start.x){
        	                        if (hi.start.y > hi.end.y){
                	                        tmp = hi.start.y;
                        	                hi.start.y = hi.end.y;
                                	        hi.end.y = tmp;
                                	}
	                                for (x = hi.start.y; x < hi.end.y; x++){
        	                                if (fig.start.y >= x - 3 && fig.start.y <= x){
                	                                if (fig.start.x >= hi.end.x - 3 && fig.start.x <= hi.end.x){
                        	                                idx = i;
                                	                        goto END;
                                        	        }
                                        	}
                                	}
                        	}
	                        else{
        	                        g = (float)(hi.end.y - hi.start.y) / (hi.end.x - hi.start.x);
	
        	                        if (hi.start.x > hi.end.x) {
                	                        start_x = hi.end.x;
                        	                end_x = hi.start.x;
                               	 	}
	                                else {
        	                                start_x = hi.start.x;
                	                        end_x = hi.end.x;
                	                }

                        	        y = g;
                                	y *= (fig.start.x - hi.start.x);
	                                y += hi.start.y;
        	                        tmp = y;
                	                for (x = start_x; x < end_x; x++){
                        	                        y = g;
                                	                y *= (x - hi.start.x);
                                        	        y += hi.start.y;
                                                	while (tmp < y) {
                                                        	if (tmp > 219) {
                                                                	tmp = 219;
	                                                                break;
        	                                                }
                	                                        if (fig.start.x >= x - 5 && fig.start.x <= x){
                        	                                        if (fig.start.y >= tmp - 5 && fig.start.y <= tmp){
                                	                                        idx = i;
                                        	                                goto END;
                                                	                }
 								}
                                                        	tmp++;
	                                                }
        	                                        while (tmp > y) {
                	                                        if (tmp < 21) {
                        	                                        tmp = 21;
                                	                                break;
                                        	                }
                                                	        if (fig.start.x >= x - 5 && fig.start.x <= x){
                                                        	        if (fig.start.y >= tmp - 5 && fig.start.y <= tmp){
                                                                	        idx = i;
                                                                       		 goto END;
	                                                                }
        	                                                }
                	                                        tmp--;
                        	                        }
	
        	                                        tmp = y;
	
        	                                        if (tmp < 21) {
                	                                        tmp = 21;
                        	                        }
                                	                else if (tmp > 219) {
                                        	                tmp = 219;
                                                	}
	                                                if (fig.start.x >= x - 5 && fig.start.x <= x){
        	                                                if (fig.start.y >= tmp - 5 && fig.start.y <= tmp){
                	                                                idx = i;
                        	                                        goto END;
                                	                        }
                                        	        }
        	                        }
                	        }
			}
			break;
		// Fill_Rect
		case 4:
			hi.start.x = figs[i].start.x; hi.start.y = figs[i].start.y;
			hi.end.x = figs[i].end.x; hi.end.y = figs[i].end.y;
			if (hi.start.x > hi.end.x){
				tmp = hi.start.x;
				hi.start.x = hi.end.x;
				hi.end.x = tmp;
			}
			if (hi.start.y > hi.end.y){
				tmp = hi.start.y;
				hi.start.y = hi.end.y;
				hi.end.y = tmp;
			}
			
			if (hi.start.x <= fig.start.x && hi.end.x >= fig.start.x){
				if (hi.start.y <= fig.start.y && hi.end.y >= fig.start.y){
					idx = i;
					goto END;
				}
			}
			break;
		// Fill_Oval
		case 5:
			hi.start.x = figs[i].start.x; hi.start.y = figs[i].start.y;
			hi.end.x = figs[i].end.x; hi.end.y = figs[i].end.y;
			if (hi.start.x > hi.end.x){
				tmp = hi.start.x;
				hi.start.x = hi.end.x;
				hi.end.x = tmp;
			}
			if (hi.start.y > hi.end.y){
				tmp = hi.start.y;
				hi.start.y = hi.end.y;
				hi.end.y = tmp;
			}

			c_x = (float)(hi.end.x + hi.start.x) / 2;
			c_y = (float)(hi.end.y + hi.start.y) / 2;
			o_a = (float)(hi.end.x - hi.start.x) / 2;
			o_b = (float)(hi.end.y = hi.start.y) / 2;

			if ((pow(o_a, 2) * pow((fig.start.x - c_x), 2) + pow(o_b, 2) * pow((fig.start.y - c_y), 2)) <= pow(o_a*o_b, 2)){
				idx = i;
				goto END;
			}
			break;
		default:
			break;
		}
	}
	END:
		return idx;
}

void clickCheck(Point pos){
	int i;

	if (midClick != 1){
		// left_menu
		if (10 <= pos.x && pos.x <= 50){
			for (i = 0; i < 7; i++){
				if ((30 * i) + 10 <= pos.y && pos.y <= (30 * i) + 30){
					leftClick = i + 1;
					//printf("left_%d\n", i);
				}
			}
		}
	
		// draw_space
		else if (60 <= pos.x && pos.x <= 260){
			if (20 <= pos.y && pos.y <= 220){
				midClick = 1;
				//printf("drawspace\n");
			}
		}

		// right_up_color_left
		else if (270 <= pos.x && pos.x <= 285){
			for (i = 0; i < 4; i++){
				if ((25 * i) + 10 <= pos.y && pos.y <= (25 * i) + 25){
					rightUpClick = i + 1;
					//printf("rightup_%d\n", i);
				}
			}
		}
		// right_up_color_right
		else if (295 <= pos.x && pos.x <= 310){
			for (i = 0; i < 4; i++){
				if ((25 * i) + 10 <= pos.y && pos.y <= (25 * i) + 25){
					rightUpClick = i + 5;
					//printf("rightup_%d\n", i);
				}
			}
		}
		// right_down_menu
		if (270 <= pos.x && pos.x <= 310){
			for (i = 0; i < 2; i++){
				if ((30 * i) + 130 <= pos.y && pos.y <= (30 * i) + 150){
					rightDnClick = i + 1;
					//printf("rightdown_%d\n", i);
				}
			}
		}
	}

}

int main(void) {

	colors[0] = makepixel(0, 0, 0);
	colors[1] = makepixel(255,255,255);
	colors[2] = makepixel(255, 0, 0);
        colors[3] = makepixel(0, 255, 0);
	colors[4] = makepixel(0, 0, 255);
	colors[5] = makepixel(255, 255, 0);
	colors[6] = makepixel(0, 255, 255);
	colors[7] = makepixel(255, 0, 255);
	int pressure = -1;
	int ret, t, i, j, figIdx;
	int figIdx_sel;
	Point get, start, end;
	Figure fig;
	Figure figs[250];
	FD_List* next;
	Figure hi;

	int x1, x2, y1, y2;
	fbfd = open(FBDEVFILE, O_RDWR);

	if (fbfd < 0) {
		perror("fbdev open");
		exit(1);
	}
	ret = ioctl(fbfd, FBIOGET_VSCREENINFO, &fbvar);
	if (ret < 0) {
		perror("fbdev ioctl");
		exit(1);
	}
	if (fbvar.bits_per_pixel != 16) {
		fprintf(stderr, "bpp is not 16\n");
		exit(1);
	}

	pfbdata = (unsigned short*)mmap(0, fbvar.xres * fbvar.yres * 16 / 8, PROT_READ | PROT_WRITE, MAP_SHARED, fbfd, 0);
	if ((unsigned)pfbdata == (unsigned)-1) {
		perror("fbdev mmap");
		exit(1);
	}

	fd = open("/dev/input/event4", O_RDONLY);
	if (fd < 0) return -1;

	printf("start\n");
	clearLcd();
	setCalibration();
	clearLcd();

	// TFT LCD init
	init_scr();

	flag = 0;
	clock = 20;

	leftClick = 0; rightUpClick = 0; rightDnClick = 0; midClick = 0;

	figIdx = 0;
	while (1) {
		pixel = makepixel(127, 255, 212);
		menu(pixel);
		for (i = 0; i < figIdx; i++) {
			switch (figs[i].type)
			{
			case 0:
				makeLine(figs[i], figs[i].color);
				break;
			case 1:
				makeRect(figs[i], figs[i].color);
				break;
			case 2:
				makeOval(figs[i], figs[i].color);
				break;
			case 3:
				next = figs[i].FD_head;
				hi.start.x = figs[i].end.x; hi.start.y = figs[i].end.y;
				hi.end.x = next->x + figs[i].end.x;	hi.end.y = next->y + figs[i].end.y;
				makeLine(hi, figs[i].color);
				while (next->link != NULL) {
					hi.start.x = hi.end.x; hi.start.y = hi.end.y;
					hi.end.x = next->x + figs[i].end.x; hi.end.y = next->y + figs[i].end.y;
					makeLine(hi, figs[i].color);
					next = next->link;
				}
				break;
			case 4:
				makeRect_Fill(figs[i], figs[i].color);
				break;
			case 5:
				makeOval_Fill(figs[i], figs[i].color);
				break;

			default:
				break;
			}
		}

		read(fd, &ie, sizeof(struct input_event));

		if (ie.type == 3){
			if (ie.code == 0){
				get.x = ie.value;
			}
			else if (ie.code == 1) {
				get.y = ie.value;
			}
			else if (ie.code == 24) {
				pressure = ie.value;
				if (pressure > 0){
					clickCheck(getLcd(get));
					// pen
					if (leftClick > 0 && leftClick < 5 && rightUpClick > 0 && rightDnClick == 1){
						if (midClick == 1 && flag == 0){
							fig.start = getLcd(get);
							flag++;
						}
						else if (midClick == 1 && flag != 0){
							fig.end = getLcd(get);
							switch(leftClick){
								case 1:
									clock--;
									fig.type = 0;
									fig.color = colors[rightUpClick - 1];
									makeLine(fig, colors[rightUpClick - 1]);
									//printf("Line\n");
									if (clock < 0){
										clear_paper();
										clock = 3;
									}
									break;
								case 2:
									clock--;
									fig.type = 1;
									fig.color = colors[rightUpClick - 1];
									makeRect(fig, colors[rightUpClick - 1]);
									//printf("Rect\n");
									if (clock < 0){
										clear_paper();
										clock = 3;
									}
									break;

								case 3:
									clock--;
									fig.type = 2;
									fig.color = colors[rightUpClick - 1];
									makeOval(fig, colors[rightUpClick - 1]);
									//printf("Oval\n");
									if (clock < 0){
										clear_paper();
										clock = 3;
									}
									break;

								case 4:
									fig.type = 3;
									fig.color = colors[rightUpClick - 1];
									fig.FD_head = Free_draw(fig, colors[rightUpClick - 1]);
									pressure = 0;
									//printf("Free draw\n");
									break;

								default:
									break;
							}
						}
						else {
							clock = 0;
						}
					}
					//fill
					else if (leftClick > 0 && leftClick < 5 && rightUpClick > 0 && rightDnClick == 2) {
						if (midClick == 1 && flag == 0) {
							fig.start = getLcd(get);
							flag++;
						}
						else if (midClick == 1 && flag != 0) {
							fig.end = getLcd(get);
							switch (leftClick) {
							case 1:
								clock--;
								fig.type = 0;
								fig.color = colors[rightUpClick - 1];
								makeLine(fig, colors[rightUpClick - 1]);
								//printf("Line\n");
								if (clock < 0) {
									clear_paper();
									clock = 3;
								}
								break;

							//fill_rec
							case 2:
								clock--;
								fig.type = 4;
								fig.color = colors[rightUpClick - 1];
								makeRect_Fill(fig, colors[rightUpClick - 1]);
								//printf("Filled_Rect\n");
								if (clock < 0) {
									clear_paper();
									clock = 3;
								}
								break;

							//fill_oval
							case 3:
								clock--;
								fig.type = 5;
								fig.color = colors[rightUpClick - 1];
								makeOval_Fill(fig, colors[rightUpClick - 1]);
								//printf("Filled_Oval\n");
								if (clock < 0) {
									clear_paper();
									clock = 3;
								}
								break;

							case 4:
								fig.type = 3;
								fig.color = colors[rightUpClick - 1];
								fig.FD_head = Free_draw(fig, colors[rightUpClick - 1]);
								pressure = 0;
								//printf("Free draw\n");
								break;

							default:
								break;
							}
						}
						else {
							clock = 0;
						}
					}

					// Select
					else if (leftClick == 5){
						if (midClick == 1 && flag == 0) {
							fig.start = getLcd(get);
							flag++;
							figIdx_sel = Select(fig, figs, figIdx);
						}
						else if (midClick == 1 && flag != 0) {
							fig.end = getLcd(get);

							switch (figs[figIdx_sel].type) {
								case 3:
									next = figs[figIdx_sel].FD_head;
									figs[figIdx_sel].start.x = figs[figIdx_sel].start.x + (fig.end.x - fig.start.x);
									figs[figIdx_sel].start.y = figs[figIdx_sel].start.y + (fig.end.y - fig.start.y);
									figs[figIdx_sel].end.x = figs[figIdx_sel].end.x + (fig.end.x - fig.start.x);
									figs[figIdx_sel].end.y = figs[figIdx_sel].end.y + (fig.end.y - fig.start.y);
									while (next->link != NULL) {
										next->x = next->x + (fig.end.x - fig.start.x);
										next->y = next->y + (fig.end.y - fig.start.y);
										next = next->link;
									}
									break;
								default:
									figs[figIdx_sel].start.x = figs[figIdx_sel].start.x + (fig.end.x - fig.start.x);
									figs[figIdx_sel].start.y = figs[figIdx_sel].start.y + (fig.end.y - fig.start.y);
									figs[figIdx_sel].end.x = figs[figIdx_sel].end.x + (fig.end.x - fig.start.x);
									figs[figIdx_sel].end.y = figs[figIdx_sel].end.y + (fig.end.y - fig.start.y);
									break;
							}
							fig.start.x = fig.end.x;
							fig.start.y = fig.end.y;
							midClick = 0;
							clear_paper();
						}
					}
					// Erase
					else if (leftClick == 6){
						fig.start = getLcd(get);
						//printf("s_x, s_y, e_x, e_y: %d %d %d %d\n", fig.start.x, fig.start.y, fig.end.x, fig.end.y);
						figIdx = Erase(fig, figs, figIdx);
						midClick = 0;
						clear_paper();
						//printf("Erase\n");
					}
					// Clear
					else if (leftClick == 7){
						init_scr();
						figIdx = 0;
						fig.start.x = 0;
						fig.start.y = 0;
						fig.end.x = 0;
						fig.end.y = 0;
						leftClick = 0;
						midClick = 0;
						//printf("Clear\n");
					}
				}
				if (pressure <= 0){
					if (midClick == 1){
						figs[figIdx++] = fig;
						midClick = 0;
					}
					flag = 0;
					//printf("fig append, figIdx: %d\n", figIdx);
				}
			}
		}
	}


	close(fd);
	close(fbfd);
	return 0;

} // end of main

